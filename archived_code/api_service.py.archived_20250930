"""
External API service layer for schedule synchronization
Handles HTTP communication with external scheduling systems
"""
import requests
import logging
import time
from typing import Dict, List, Optional, Any
from datetime import datetime
from flask import current_app


class APIError(Exception):
    """Custom exception for API errors"""
    def __init__(self, message: str, status_code: int = None, response_data: Any = None):
        self.message = message
        self.status_code = status_code
        self.response_data = response_data
        super().__init__(self.message)


class ExternalAPIService:
    """Service class for external API integration"""

    def __init__(self, app=None):
        self.app = app
        self.logger = logging.getLogger(__name__)
        if app is not None:
            self.init_app(app)

    def init_app(self, app):
        """Initialize the API service with Flask app"""
        self.app = app
        self.base_url = app.config.get('EXTERNAL_API_BASE_URL', '')
        self.api_key = app.config.get('EXTERNAL_API_KEY', '')
        self.timeout = app.config.get('EXTERNAL_API_TIMEOUT', 30)
        self.max_retries = app.config.get('EXTERNAL_API_MAX_RETRIES', 3)
        self.retry_delay = app.config.get('EXTERNAL_API_RETRY_DELAY', 1)

        # Session configuration for connection pooling
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.api_key}',
            'User-Agent': 'Flask-Scheduler/1.0'
        })

    def _make_request(self, method: str, endpoint: str, **kwargs) -> requests.Response:
        """Make HTTP request with retry logic"""
        url = f"{self.base_url.rstrip('/')}/{endpoint.lstrip('/')}"

        for attempt in range(self.max_retries + 1):
            try:
                response = self.session.request(
                    method=method,
                    url=url,
                    timeout=self.timeout,
                    **kwargs
                )

                # Log the request
                self.logger.info(f"{method} {url} - Status: {response.status_code}")

                # Check for HTTP errors
                if response.status_code >= 400:
                    error_msg = f"API request failed: {method} {url} - {response.status_code}"
                    if response.text:
                        error_msg += f" - {response.text}"

                    raise APIError(
                        message=error_msg,
                        status_code=response.status_code,
                        response_data=response.text
                    )

                return response

            except requests.exceptions.RequestException as e:
                self.logger.warning(f"Request attempt {attempt + 1} failed: {str(e)}")

                if attempt < self.max_retries:
                    time.sleep(self.retry_delay * (2 ** attempt))  # Exponential backoff
                else:
                    raise APIError(f"API request failed after {self.max_retries + 1} attempts: {str(e)}")

    def get_events(self, start_date: datetime = None, end_date: datetime = None) -> List[Dict]:
        """Fetch events from external API"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return []

        params = {}
        if start_date:
            params['start_date'] = start_date.isoformat()
        if end_date:
            params['end_date'] = end_date.isoformat()

        try:
            response = self._make_request('GET', '/events', params=params)
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to fetch events: {e.message}")
            raise

    def create_schedule(self, event_data: Dict) -> Dict:
        """Create a new schedule in external system"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return {}

        try:
            response = self._make_request('POST', '/schedules', json=event_data)
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to create schedule: {e.message}")
            raise

    def update_schedule(self, external_id: str, event_data: Dict) -> Dict:
        """Update existing schedule in external system"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return {}

        try:
            response = self._make_request('PUT', f'/schedules/{external_id}', json=event_data)
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to update schedule {external_id}: {e.message}")
            raise

    def delete_schedule(self, external_id: str) -> bool:
        """Delete schedule from external system"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return True

        try:
            self._make_request('DELETE', f'/schedules/{external_id}')
            return True
        except APIError as e:
            self.logger.error(f"Failed to delete schedule {external_id}: {e.message}")
            raise

    def get_employees(self) -> List[Dict]:
        """Fetch employees from external API"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return []

        try:
            response = self._make_request('GET', '/employees')
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to fetch employees: {e.message}")
            raise

    def create_employee(self, employee_data: Dict) -> Dict:
        """Create a new employee in external system"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return {}

        try:
            response = self._make_request('POST', '/employees', json=employee_data)
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to create employee: {e.message}")
            raise

    def update_employee(self, external_id: str, employee_data: Dict) -> Dict:
        """Update existing employee in external system"""
        if not self.base_url:
            self.logger.warning("External API not configured")
            return {}

        try:
            response = self._make_request('PUT', f'/employees/{external_id}', json=employee_data)
            return response.json()
        except APIError as e:
            self.logger.error(f"Failed to update employee {external_id}: {e.message}")
            raise

    def health_check(self) -> Dict:
        """Check API connectivity and health"""
        if not self.base_url:
            return {
                'status': 'disabled',
                'message': 'External API not configured'
            }

        try:
            response = self._make_request('GET', '/health')
            return {
                'status': 'healthy',
                'message': 'API connection successful',
                'data': response.json() if response.text else None
            }
        except APIError as e:
            return {
                'status': 'unhealthy',
                'message': f'API connection failed: {e.message}',
                'status_code': e.status_code
            }

    def transform_local_to_external(self, local_schedule: Dict) -> Dict:
        """Transform local schedule data to external API format"""
        # This is a template - customize based on your external API schema
        return {
            'event_id': local_schedule.get('event_ref_num'),
            'employee_id': local_schedule.get('employee_id'),
            'scheduled_datetime': local_schedule.get('schedule_datetime'),
            'project_name': local_schedule.get('project_name'),
            'location': local_schedule.get('store_name'),
            'estimated_duration': local_schedule.get('estimated_time'),
        }

    def transform_external_to_local(self, external_data: Dict) -> Dict:
        """Transform external API data to local format"""
        # This is a template - customize based on your external API schema
        return {
            'external_id': external_data.get('id'),
            'project_ref_num': external_data.get('event_id'),
            'employee_id': external_data.get('employee_id'),
            'schedule_datetime': external_data.get('scheduled_datetime'),
            'project_name': external_data.get('project_name'),
            'store_name': external_data.get('location'),
            'estimated_time': external_data.get('estimated_duration'),
        }


# Global instance
external_api = ExternalAPIService()