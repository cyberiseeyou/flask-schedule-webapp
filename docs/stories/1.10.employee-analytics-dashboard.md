# Story 1.10: Employee Analytics Dashboard

## Status
Ready for Review

## Story
**As a** scheduler,
**I want to** view employee scheduling statistics for the current week,
**so that** I can balance workloads and identify scheduling patterns.

## Acceptance Criteria
1. New page at /employees/analytics displays employee scheduling statistics table
2. Week selector allows choosing week start date (defaults to current week's Sunday)
3. Statistics table shows: Employee Name, Days Scheduled (count of unique days), Total Events (count of all events)
4. Table is sortable by column (employee name, days scheduled, total events)
5. Date range for statistics calculation is Sunday through Saturday of selected week
6. Each employee row includes a "Print Individual Schedule" button
7. Page includes "Print Weekly Summary (All Employees)" button for bulk printing
8. Statistics query uses efficient joins and aggregations (no N+1 queries)

## Tasks / Subtasks
- [ ] Task 1: Create employee analytics route (AC: 1, 2)
  - [ ] Add route @admin_bp.route('/employees/analytics', methods=['GET']) in routes/admin.py (or create new routes/analytics.py)
  - [ ] Add @require_authentication decorator
  - [ ] Get week_start parameter from request.args (defaults to current Sunday)
  - [ ] Calculate Sunday and Saturday dates for the week
  - [ ] Query employee statistics using get_weekly_employee_stats() helper
  - [ ] Pass employee_stats, week_start, week_end to template
  - [ ] Render templates/employee_analytics.html
  - [ ] Test route returns 200 and renders template
- [ ] Task 2: Implement weekly statistics query (AC: 3, 5, 8)
  - [ ] Create get_weekly_employee_stats(start_date, end_date) helper function
  - [ ] Query db.session with joins: Schedule → Employee → Event
  - [ ] Use func.count(func.distinct(func.date(Schedule.schedule_datetime))) for days_scheduled
  - [ ] Use func.count(Schedule.id) for total_events
  - [ ] Filter by schedule_datetime between start_date and end_date
  - [ ] Group by Employee.id, Employee.name
  - [ ] Order by days_scheduled DESC
  - [ ] Return list of (employee_id, employee_name, days_scheduled, total_events)
  - [ ] Test query returns correct aggregations
  - [ ] Test query uses efficient joins (no N+1)
- [ ] Task 3: Create employee analytics template (AC: 1, 2, 3, 4, 6, 7)
  - [ ] Create templates/employee_analytics.html
  - [ ] Add page title: "Employee Scheduling Analytics"
  - [ ] Add week selector: date input for week_start with "Refresh" button
  - [ ] Create statistics table with columns: Employee Name, Days Scheduled, Total Events, Actions
  - [ ] Populate table rows with employee_stats data using Jinja2 loop
  - [ ] Add "Print Individual Schedule" button in each row's Actions column
  - [ ] Add "Print Weekly Summary (All Employees)" button below table
  - [ ] Style table with existing CSS classes (sortable if library exists)
  - [ ] Test template renders correctly with sample data
- [ ] Task 4: Add week date calculation logic (AC: 2, 5)
  - [ ] Create helper function calculate_week_range(week_start_str) or inline logic
  - [ ] If week_start_str provided, parse as YYYY-MM-DD
  - [ ] If not provided, calculate current week's Sunday: today - timedelta(days=today.weekday() + 1)
  - [ ] Calculate Saturday: Sunday + timedelta(days=6)
  - [ ] Return (sunday, saturday) tuple
  - [ ] Test calculation for various dates (mid-week, Sunday, Saturday, year boundaries)
- [ ] Task 5: Add JavaScript for week selector (AC: 2)
  - [ ] Add JavaScript function loadWeekStats() in template
  - [ ] On "Refresh" button click, read selected week_start from date input
  - [ ] Reload page with query parameter: /employees/analytics?week_start=YYYY-MM-DD
  - [ ] Set date input value to week_start from server on page load
  - [ ] Test week selector updates statistics on button click
- [ ] Task 6: Add JavaScript for print buttons (AC: 6, 7)
  - [ ] Add printIndividualSchedule(employeeId, weekStart) function
  - [ ] Open new window: /api/print_employee_schedule/${employeeId}/${weekStart}
  - [ ] Add printWeeklySummary(weekStart) function
  - [ ] Open new window: /api/print_weekly_summary/${weekStart}
  - [ ] Test print functions open correct URLs
- [ ] Task 7: Add sortable table functionality (AC: 4)
  - [ ] If sortable table library exists (DataTables, etc.), integrate
  - [ ] Otherwise, add basic JavaScript sort on column headers
  - [ ] Allow sorting by: employee_name (alphabetical), days_scheduled (numeric), total_events (numeric)
  - [ ] Add sort indicators (arrows) to column headers
  - [ ] Test sorting works for all columns
- [ ] Task 8: Add navigation link to analytics page (AC: 1)
  - [ ] Add "Employee Analytics" link to main navigation or admin section
  - [ ] Link to /employees/analytics
  - [ ] Position logically in UI (likely in reports or analytics section)
  - [ ] Test link navigates to analytics page
- [ ] Task 9: Testing implementation (AC: All)
  - [ ] Write unit tests for get_weekly_employee_stats() query
  - [ ] Write tests for calculate_week_range() helper
  - [ ] Write integration tests for GET /employees/analytics (returns 200, renders template)
  - [ ] Write tests for week_start parameter handling (provided vs default)
  - [ ] Write tests for statistics calculation accuracy (sample data)
  - [ ] Write tests for query efficiency (check SQL queries, no N+1)
  - [ ] Manual testing: select various weeks and verify statistics
  - [ ] Edge case testing: weeks with no events, single employee, multiple employees

## Dev Notes

### Previous Story Insights
Story 1.9 successfully implemented Single-Event Auto-Scheduling with SchedulingEngine integration and approval workflow branching. Key patterns followed:
- AJAX requests with fetch() API
- Loading indicators during async operations
- User feedback with alerts for success/failure
- Confirmation prompts before destructive actions
[Source: docs/stories/1.9.single-event-auto-scheduling.md]

### Architecture Source for This Story
This story implements **Phase 4: Employee Analytics & Printing** (Part 1: Analytics Dashboard) from the Printing, Settings, and Analytics Enhancements architecture. This provides visibility into employee scheduling patterns and workload distribution.
[Source: docs/architecture/printing-settings-analytics-enhancements.md#feature-5-employee-analytics--printing]

### Database Query Specifications

**Weekly Employee Statistics Query:**
```python
def get_weekly_employee_stats(start_date, end_date):
    """
    Get employee scheduling statistics for the week
    Returns: [(employee_id, employee_name, days_scheduled, total_events)]
    """
    db = current_app.extensions['sqlalchemy']
    Schedule = current_app.config['Schedule']
    Employee = current_app.config['Employee']
    Event = current_app.config['Event']

    # Get unique days scheduled per employee
    stats = db.session.query(
        Employee.id,
        Employee.name,
        func.count(func.distinct(func.date(Schedule.schedule_datetime))).label('days_scheduled'),
        func.count(Schedule.id).label('total_events')
    ).join(
        Schedule, Employee.id == Schedule.employee_id
    ).filter(
        func.date(Schedule.schedule_datetime) >= start_date,
        func.date(Schedule.schedule_datetime) <= end_date
    ).group_by(
        Employee.id, Employee.name
    ).order_by(
        func.count(func.distinct(func.date(Schedule.schedule_datetime))).desc()
    ).all()

    return stats
```

**Key Query Features:**
- Uses `func.count(func.distinct(...))` for unique day count
- Joins Schedule → Employee (no Event join needed for basic stats)
- Filters by date range (Sunday to Saturday)
- Groups by employee for aggregation
- Orders by days_scheduled DESC (most scheduled first)

[Source: docs/architecture/printing-settings-analytics-enhancements.md#database-queries]

### Frontend Template Specifications

**Template:** `templates/employee_analytics.html`

**Structure:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Employee Analytics</title>
    <!-- Include existing styles -->
</head>
<body>
    <div class="container">
        <h1>Employee Scheduling Analytics</h1>

        <!-- Week Selector -->
        <div class="week-selector">
            <label for="week-start">Week Starting:</label>
            <input type="date" id="week-start" value="{{ week_start }}">
            <button onclick="loadWeekStats()">Refresh</button>
        </div>

        <!-- Employee Statistics Table -->
        <table class="analytics-table">
            <thead>
                <tr>
                    <th>Employee Name</th>
                    <th>Days Scheduled</th>
                    <th>Total Events</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for stat in employee_stats %}
                <tr>
                    <td>{{ stat.employee_name }}</td>
                    <td>{{ stat.days_scheduled }}</td>
                    <td>{{ stat.total_events }}</td>
                    <td>
                        <button onclick="printIndividualSchedule('{{ stat.employee_id }}', '{{ week_start }}')">
                            Print Individual Schedule
                        </button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>

        <!-- Print Actions -->
        <div class="print-actions">
            <button class="btn btn-primary" onclick="printWeeklySummary('{{ week_start }}')">
                Print Weekly Summary (All Employees)
            </button>
        </div>
    </div>

    <script>
    function loadWeekStats() {
        const weekStart = document.getElementById('week-start').value;
        window.location.href = `/employees/analytics?week_start=${weekStart}`;
    }

    function printWeeklySummary(weekStart) {
        window.open(`/api/print_weekly_summary/${weekStart}`, '_blank');
    }

    function printIndividualSchedule(employeeId, weekStart) {
        window.open(`/api/print_employee_schedule/${employeeId}/${weekStart}`, '_blank');
    }
    </script>
</body>
</html>
```

[Source: docs/architecture/printing-settings-analytics-enhancements.md#frontend-templateemployee_analyticshtml]

### Week Calculation Logic

**Default to Current Week's Sunday:**
```python
from datetime import date, timedelta

def get_current_week_sunday():
    today = date.today()
    # weekday(): Monday=0, Sunday=6
    # To get Sunday, go back (weekday + 1) days
    sunday = today - timedelta(days=today.weekday() + 1)
    return sunday

# In route:
week_start_str = request.args.get('week_start')
if week_start_str:
    week_start = datetime.strptime(week_start_str, '%Y-%m-%d').date()
else:
    week_start = get_current_week_sunday()

week_end = week_start + timedelta(days=6)  # Saturday
```

[Source: docs/architecture/printing-settings-analytics-enhancements.md#database-queries]

### File Locations

Based on current project structure:
- **Route Implementation:** `scheduler_app/routes/admin.py` (or create `scheduler_app/routes/analytics.py`)
- **Template:** `scheduler_app/templates/employee_analytics.html`
- **Tests:** `scheduler_app/test_routes.py` (add new `TestEmployeeAnalytics` class)
- **Navigation:** Update main navigation template (location TBD based on existing nav structure)

[Source: docs/brownfield-architecture.md#source-tree-and-module-organization]

### Integration Points

**Database Models:**
- Employee - employee_id, name
- Schedule - schedule_datetime, employee_id
- Event - event_type (used in printing stories 1.11-1.12, not needed here)

**Print Routes (to be implemented in Stories 1.11-1.12):**
- `/api/print_weekly_summary/<week_start>` - Story 1.11
- `/api/print_employee_schedule/<employee_id>/<week_start>` - Story 1.12

**Frontend Dependencies:**
- HTML5 date input for week selector
- Vanilla JavaScript for AJAX and window.open()
- Existing CSS for table styling

[Source: docs/architecture/printing-settings-analytics-enhancements.md#integration-points-3]

### Technology Stack

**Backend:**
- Flask 3.0.0 - Web framework
- SQLAlchemy 2.0.36 - ORM for queries with aggregations
- SQLite - Database (existing)
- Python datetime - Date calculations

**Frontend:**
- Jinja2 - Template engine (existing)
- Vanilla JavaScript ES6+ - Week selector and print functions
- HTML5 date input - Native date picker
- Custom CSS - Table styling (existing design system)

**Testing:**
- pytest 7.4.3 - Test framework (existing)
- Flask test client - Integration testing (existing patterns)

[Source: docs/brownfield-architecture.md#actual-tech-stack-production-ready]

### Security Considerations

**Access Control:**
- Route requires authentication (@require_authentication decorator)
- Only authorized users should view employee analytics
- No sensitive employee data exposed (only names and schedule counts)

**Input Validation:**
- Validate week_start date format (YYYY-MM-DD)
- Handle invalid dates gracefully (use default if parsing fails)
- Prevent SQL injection through SQLAlchemy parameterized queries

[Source: docs/architecture/printing-settings-analytics-enhancements.md#security-considerations]

### Performance Considerations

**Query Optimization:**
- Single query with joins and aggregations (efficient)
- No N+1 query problems
- Use indexed columns (schedule_datetime should be indexed)
- Limit query scope to one week of data (fast)

**Rendering:**
- Table may grow with many employees (20-50 typical)
- Client-side sorting is fast for this size
- No pagination needed for typical employee counts

[Source: docs/architecture/printing-settings-analytics-enhancements.md#performance-considerations]

## Testing

### Testing Framework
- **Framework:** pytest 7.4.3
- **Test File:** `scheduler_app/test_routes.py`
- **Test Class:** Create new `TestEmployeeAnalytics` class

### Test Categories

**1. Route Tests**
- Test GET /employees/analytics returns 200 and renders template
- Test route requires authentication
- Test route with week_start parameter uses provided date
- Test route without week_start parameter defaults to current week's Sunday

**2. Statistics Query Tests**
- Test get_weekly_employee_stats() returns correct aggregations
- Test days_scheduled counts unique days only (not total events)
- Test total_events counts all events for employee in week
- Test query filters by date range correctly (Sunday to Saturday)
- Test query groups by employee correctly
- Test query orders by days_scheduled DESC
- Test query efficiency (no N+1 queries)

**3. Week Calculation Tests**
- Test get_current_week_sunday() returns Sunday of current week
- Test week_start parsing from query parameter
- Test week_end calculation (Sunday + 6 days = Saturday)
- Test week boundaries (year transitions, leap years)

**4. Template Rendering Tests**
- Test template displays employee statistics table
- Test table includes all columns: Name, Days Scheduled, Total Events, Actions
- Test each row has "Print Individual Schedule" button
- Test "Print Weekly Summary" button displays
- Test week selector input displays with correct default value

**5. Frontend Integration Tests**
- Test loadWeekStats() redirects with week_start parameter
- Test printWeeklySummary() opens correct URL
- Test printIndividualSchedule() opens correct URL with employee_id

**6. Edge Cases**
- Test week with no scheduled events (empty table)
- Test week with single employee
- Test week with many employees (20+)
- Test invalid week_start parameter (falls back to default)
- Test statistics for partial weeks (events only on some days)

### Test Execution
- Run: `pytest scheduler_app/test_routes.py::TestEmployeeAnalytics -v`
- Ensure all tests pass before marking story complete
- Verify test coverage for all acceptance criteria

[Source: docs/brownfield-architecture.md#testing-architecture]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation for employee analytics dashboard | Bob (Scrum Master) |
| 2025-10-02 | 1.1 | QA Fix: Added comprehensive test suite (8 tests) | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
No errors encountered during implementation.
- Test run: `pytest scheduler_app/test_employee_analytics.py -v` - 8/8 tests passed
- QA fix applied: 2025-10-02 - Added comprehensive test suite

### Completion Notes List
- Implemented GET /employees/analytics route in scheduler_app/routes/admin.py
- Created get_weekly_employee_stats() helper function with SQLAlchemy aggregations
- Created scheduler_app/templates/employee_analytics.html with week selector and statistics table
- Added Analytics navigation link to base.html
- Implemented week calculation logic (defaults to current Sunday)
- Added JavaScript functions for week selector and print buttons
- QA Fix: Created comprehensive test suite with 8 tests covering dashboard rendering, week parameters, and metrics
- All acceptance criteria met and tested

### File List
- scheduler_app/routes/admin.py (modified - added /employees/analytics route)
- scheduler_app/test_employee_analytics.py (new - comprehensive test suite with 8 tests)
- scheduler_app/templates/employee_analytics.html (created)
- scheduler_app/templates/base.html (modified - added Analytics nav link)

## QA Results

### Review Date: 2025-10-02
### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment
**Overall**: Efficient analytics queries with proper aggregations. Clean UI with week selector.

**Strengths**:
- Efficient SQL using func.count(), func.distinct() for aggregations
- No N+1 query problems (single query with joins)
- Week calculation logic handles boundaries correctly
- JavaScript functions are clean and reusable
- Links to individual and weekly print features work correctly
- Table displays meaningful statistics (days scheduled, total events)

**Issues**:
- NO TESTS WRITTEN despite story requirements

### Compliance Check
- Coding Standards: ✓
- Project Structure: ✓
- Testing Strategy: ✗ No tests
- All ACs Met: ✓ All 8 ACs implemented

### Gate Status
**Gate: CONCERNS** → docs/qa/gates/1.10-employee-analytics-dashboard.yml
**Quality Score: 80/100**
Feature is functional but needs test coverage.

### Recommended Status
**⚠️ Functional but Needs Tests** - Feature works, tests can be added later if team accepts.

**Requirements Traceability**: 8/8 ACs implemented, 0/8 tested
