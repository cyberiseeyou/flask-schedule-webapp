# Enhancement #3: Database Migration Strategy

**Priority**: 🔴 P0 - Critical
**Effort**: Medium (4-6 hours)
**Impact**: High - Enables safe schema changes and deployments

---

## **Why This Enhancement Matters**

**Current Problem:**
The codebase has **6 manual migration scripts**:
- `migrate_db.py`
- `migrate_employee_ids.py`
- `migrate_employees.py`
- `migrate_time_off.py`
- `update_employee_list.py`
- `update_event_types.py`

**Issues with Manual Migrations:**

1. **No Version Control**: Can't track what schema changes were applied
2. **Not Repeatable**: Can't easily apply same changes to dev/staging/prod
3. **Error Prone**: Manual scripts can be run out of order or multiple times
4. **No Rollback**: Can't undo migrations if something goes wrong
5. **Team Coordination**: Hard to know what scripts to run when pulling changes
6. **Data Loss Risk**: Mistakes in manual scripts can corrupt data

**Real-World Scenario:**
```
Developer A: Adds new column to Employee model
Developer B: Pulls changes, app crashes with "column not found"
Developer B: Doesn't know which script to run
Developer A: "Oh, I forgot to commit the migration script"
```

**Goal**: Implement Flask-Migrate (Alembic) for automated, version-controlled database migrations.

---

## **System Prompt for AI Agent**

```
You are implementing Flask-Migrate for database schema version control.

CRITICAL RULES:
1. NEVER delete existing database files until migrations are tested
2. ALWAYS create backup before running migrations
3. Test migrations on development database first
4. Generate migrations automatically - don't write them manually
5. Review autogenerated migrations before applying
6. Keep manual scripts until migration system is proven working

MOST IMPORTANT:
- Flask-Migrate must be initialized BEFORE creating any migrations
- Migrations run in order by timestamp - never rename migration files
- Always use `flask db upgrade` (never edit database manually)
- Downgrade scripts are auto-generated - test them too

IGNORE/REMOVE FROM CONTEXT:
- Manual migration scripts (we'll convert them later)
- Old database schema discussions
- Historical database issues
```

---

## **Step-by-Step Implementation Guide**

### **Phase 1: Install and Initialize Flask-Migrate**

#### **Step 1.1: Install Dependencies**

**System Prompt:**
```
Install Flask-Migrate and its dependencies.
Update requirements.txt with pinned versions.
```

**Actions:**
```bash
cd /c/Users/mathe/flask-schedule-webapp/scheduler_app

# Activate virtual environment
source ../venv/bin/activate  # Linux/Mac
# OR
../venv/Scripts/activate  # Windows

# Install Flask-Migrate
pip install Flask-Migrate==4.0.5

# Update requirements.txt
pip freeze | grep -E "Flask-Migrate|alembic" >> requirements.txt
```

**Verify installation:**
```bash
python -c "import flask_migrate; print(flask_migrate.__version__)"
# Should output: 4.0.5
```

**Update requirements.txt properly:**

Edit `scheduler_app/requirements.txt`:

```txt
Flask==3.0.0
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.5
alembic==1.13.1
python-decouple==3.8
requests==2.31.0
PyPDF2==3.0.1
reportlab==4.0.7
urllib3==2.0.7
```

**Why pinned versions:**
- Prevents breaking changes from automatic updates
- Ensures consistent behavior across environments
- Makes debugging easier (everyone has same versions)

---

#### **Step 1.2: Initialize Flask-Migrate in Application**

**System Prompt:**
```
Add Flask-Migrate to the Flask app initialization.
This must happen AFTER db is initialized but BEFORE routes are registered.
```

**Edit scheduler_app/app.py:**

Find the section where Flask and extensions are initialized (around line 30-50):

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate  # ADD THIS IMPORT
from config import get_config
from session_api_service import session_api as external_api
from sync_engine import sync_engine
from error_handlers import setup_logging, register_error_handlers

app = Flask(__name__)

# Load configuration
config_class = get_config()
app.config.from_object(config_class)

# Ensure instance directory exists
basedir = os.path.abspath(os.path.dirname(__file__))
os.makedirs(os.path.join(basedir, "instance"), exist_ok=True)

# Initialize extensions
db = SQLAlchemy(app)
migrate = Migrate(app, db)  # ADD THIS LINE - Initialize Flask-Migrate

external_api.init_app(app)
sync_engine.init_app(app, db)
```

**Why this order matters:**
1. `db = SQLAlchemy(app)` creates database connection
2. `migrate = Migrate(app, db)` sets up migration tracking
3. Models are defined (using db)
4. Routes are registered (using models)

**If order is wrong:**
- Migrations won't detect model changes
- App may crash on startup

---

#### **Step 1.3: Initialize Migration Repository**

**System Prompt:**
```
Create the migrations directory structure.
This is a one-time initialization that creates version control for the database.
```

**Actions:**
```bash
cd /c/Users/mathe/flask-schedule-webapp/scheduler_app

# Initialize migrations
flask db init

# OR if flask command not found:
python -m flask db init
```

**Expected Output:**
```
Creating directory /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations ...  done
Creating directory /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/versions ...  done
Generating /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/script.py.mako ...  done
Generating /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/env.py ...  done
Generating /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/README ...  done
Generating /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/alembic.ini ...  done
Please edit configuration/connection/logging settings in '/c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/alembic.ini' before proceeding.
```

**Created structure:**
```
scheduler_app/
├── migrations/              # NEW - Migration version control
│   ├── versions/           # Individual migration scripts
│   ├── env.py             # Migration environment config
│   ├── script.py.mako     # Template for new migrations
│   ├── alembic.ini        # Alembic configuration
│   └── README             # Migration instructions
├── app.py
└── ...
```

**Verify creation:**
```bash
ls -la migrations/
# Should show: env.py, script.py.mako, alembic.ini, versions/
```

---

### **Phase 2: Create Initial Migration**

#### **Step 2.1: Backup Existing Database**

**System Prompt:**
```
CRITICAL: Backup the existing database before creating migrations.
If something goes wrong, we can restore from this backup.
```

**Actions:**
```bash
cd /c/Users/mathe/flask-schedule-webapp/scheduler_app

# Check if database exists
ls -la instance/scheduler.db

# Create backup with timestamp
BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
cp instance/scheduler.db instance/scheduler_backup_${BACKUP_DATE}.db

# Verify backup
ls -la instance/scheduler_backup_*.db
```

**Why backup before migrations:**
- Migrations can fail and corrupt database
- Allows quick rollback if issues occur
- Preserves production data during testing

---

#### **Step 2.2: Generate Initial Migration**

**System Prompt:**
```
Generate the initial migration from current models.
This creates a snapshot of the current database schema.

Flask-Migrate will compare models (in app.py) with the database
and generate the necessary migration script.
```

**Actions:**
```bash
cd /c/Users/mathe/flask-schedule-webapp/scheduler_app

# Generate migration
flask db migrate -m "Initial migration - existing schema"

# OR if flask command not found:
python -m flask db migrate -m "Initial migration - existing schema"
```

**Expected Output:**
```
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'employees'
INFO  [alembic.autogenerate.compare] Detected added table 'events'
INFO  [alembic.autogenerate.compare] Detected added table 'schedules'
INFO  [alembic.autogenerate.compare] Detected added table 'employee_weekly_availability'
INFO  [alembic.autogenerate.compare] Detected added table 'employee_availability'
INFO  [alembic.autogenerate.compare] Detected added table 'employee_time_off'
INFO  [alembic.autogenerate.compare] Detected added index 'idx_schedules_date' on '['schedule_datetime']'
INFO  [alembic.autogenerate.compare] Detected added index 'idx_employee_time_off_dates' on '['employee_id', 'start_date', 'end_date']'
  Generating /c/Users/mathe/flask-schedule-webapp/scheduler_app/migrations/versions/abc123def456_initial_migration_existing_schema.py ...  done
```

**Created file:**
```
migrations/versions/abc123def456_initial_migration_existing_schema.py
```

**Why "initial migration":**
- Establishes baseline for future changes
- All tables/columns/indexes captured in version control
- Future migrations build on this foundation

---

#### **Step 2.3: Review Generated Migration**

**System Prompt:**
```
ALWAYS review autogenerated migrations before applying them.
Alembic is smart but not perfect - it can make mistakes.
```

**Read the generated migration:**

```bash
cd migrations/versions
ls -lt *.py | head -1  # Find newest migration
cat abc123def456_initial_migration_existing_schema.py
```

**What to look for:**

```python
"""Initial migration - existing schema

Revision ID: abc123def456
Revises:
Create Date: 2025-09-30 10:30:00.123456

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = None  # This is the first migration
branch_labels = None
depends_on = None


def upgrade():
    """Apply migration - create all tables"""
    # Create employees table
    op.create_table('employees',
        sa.Column('id', sa.String(length=50), nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('email', sa.String(length=120), nullable=True),
        # ... more columns
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')
    )

    # Create events table
    op.create_table('events',
        # ... columns
    )

    # Create indexes
    op.create_index('idx_schedules_date', 'schedules', ['schedule_datetime'])


def downgrade():
    """Rollback migration - drop all tables"""
    op.drop_index('idx_schedules_date', table_name='schedules')
    op.drop_table('schedules')
    op.drop_table('events')
    op.drop_table('employees')
```

**Check for common issues:**

✅ **Good signs:**
- All expected tables are created
- Foreign keys are correct
- Indexes are included
- Column types match model definitions
- Downgrade script exists

❌ **Red flags:**
- Missing tables (compare with models in app.py)
- Wrong column types (e.g., String should be Text)
- Missing indexes that exist in models
- Foreign keys point to wrong tables
- Downgrade script doesn't reverse upgrade

**If migration looks wrong:**
```bash
# Delete the generated migration
rm migrations/versions/abc123def456_initial_migration_existing_schema.py

# Regenerate it
flask db migrate -m "Initial migration - existing schema"

# Review again
```

---

#### **Step 2.4: Apply Initial Migration**

**System Prompt:**
```
Apply the migration to the database.
This creates a migration_version table to track what's been applied.

Since this is the first migration and database already exists,
we'll use a special technique called "stamping" to mark it as applied
without actually running the SQL (which would fail on existing tables).
```

**For EXISTING database (recommended):**

```bash
cd /c/Users/mathe/flask-schedule-webapp/scheduler_app

# Mark the migration as applied WITHOUT running it
# This tells Alembic "the database is already at this state"
flask db stamp head

# Verify it worked
flask db current
```

**Expected Output:**
```
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
abc123def456 (head)
```

**For NEW database (empty):**

```bash
# Run the migration normally
flask db upgrade

# This creates all tables from scratch
```

**What `stamp head` does:**
- Adds entry to `alembic_version` table: `abc123def456`
- Does NOT run CREATE TABLE statements
- Tells migration system: "database matches this migration"

**Why stamp instead of upgrade:**
- Database already has tables (created by `db.create_all()`)
- Running upgrade would try to CREATE TABLE again = error
- Stamping acknowledges existing state

---

### **Phase 3: Migrate from Manual Scripts**

#### **Step 3.1: Analyze Existing Manual Migrations**

**System Prompt:**
```
Review the 6 manual migration scripts to understand what changes they made.
We'll convert these to proper migrations.
```

**Read each script:**

```bash
cd /c/Users/mathe/flask-schedule-webapp

# List all migration scripts
ls -la migrate*.py update*.py

# Examine each one
for script in migrate*.py update*.py; do
    echo "=== $script ==="
    head -20 "$script"
    echo ""
done
```

**Document what each script does:**

1. **migrate_db.py**: Database structure changes
2. **migrate_employee_ids.py**: Changed employee ID format
3. **migrate_employees.py**: Added new employee fields
4. **migrate_time_off.py**: Created time_off table
5. **update_employee_list.py**: Synced employee data
6. **update_event_types.py**: Added event_type column

**Categorize migrations:**
- **Schema changes** (need real migrations): #1, #3, #4, #6
- **Data migrations** (need data scripts): #2, #5

---

#### **Step 3.2: Create Data Migration Example**

**System Prompt:**
```
Some migrations aren't just schema changes - they transform data.
For these, we create migrations that run SQL or Python code.
```

**Example: Adding event_type column and populating it**

```bash
# Create a new migration
flask db revision -m "Add event_type column and detect types"
```

**Edit the generated migration:**

```python
"""Add event_type column and detect types

Revision ID: def789ghi012
Revises: abc123def456
Create Date: 2025-09-30 11:00:00.123456

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import table, column

# revision identifiers
revision = 'def789ghi012'
down_revision = 'abc123def456'  # Previous migration
branch_labels = None
depends_on = None


def upgrade():
    """Add event_type column and populate based on project_name"""

    # Step 1: Add column (nullable initially)
    op.add_column('events', sa.Column('event_type', sa.String(20), nullable=True))

    # Step 2: Populate the column with detected types
    # Create a simple table representation for the query
    events_table = table('events',
        column('id', sa.Integer),
        column('project_name', sa.Text),
        column('event_type', sa.String)
    )

    # Update event types based on project name patterns
    connection = op.get_bind()

    # Core events
    connection.execute(
        events_table.update()
        .where(events_table.c.project_name.like('%CORE%'))
        .values(event_type='Core')
    )

    # Digital events
    connection.execute(
        events_table.update()
        .where(events_table.c.project_name.like('%DIGITAL%'))
        .values(event_type='Digitals')
    )

    # Juicer events
    connection.execute(
        events_table.update()
        .where(events_table.c.project_name.like('%JUICER%'))
        .values(event_type='Juicer')
    )

    # Default for unmatched
    connection.execute(
        events_table.update()
        .where(events_table.c.event_type == None)
        .values(event_type='Other')
    )

    # Step 3: Make column non-nullable with default
    op.alter_column('events', 'event_type',
                    existing_type=sa.String(20),
                    nullable=False,
                    server_default='Other')


def downgrade():
    """Remove event_type column"""
    op.drop_column('events', 'event_type')
```

**Why this pattern:**
- Schema change + data transformation in one migration
- Uses SQLAlchemy Core (not ORM) for reliability
- Can be run multiple times (idempotent)
- Downgrade removes the column

**Apply the migration:**
```bash
flask db upgrade
```

---

#### **Step 3.3: Archive Manual Scripts**

**System Prompt:**
```
Once migrations are converted and tested, archive the manual scripts.
Don't delete them yet - keep as reference.
```

**Actions:**
```bash
cd /c/Users/mathe/flask-schedule-webapp

# Create archive directory
mkdir -p scheduler_app/migrations/archived_manual_scripts

# Move old scripts
mv migrate*.py scheduler_app/migrations/archived_manual_scripts/
mv update*.py scheduler_app/migrations/archived_manual_scripts/

# Create README
cat > scheduler_app/migrations/archived_manual_scripts/README.md << 'EOF'
# Archived Manual Migration Scripts

These scripts were used before implementing Flask-Migrate.
They are kept for historical reference only.

**DO NOT RUN THESE SCRIPTS**

All migrations are now handled by Flask-Migrate in the `versions/` directory.

## Original Scripts

- `migrate_db.py`: Early database structure changes
- `migrate_employee_ids.py`: Employee ID format migration (replaced by migration abc123)
- `migrate_employees.py`: Added employee fields (replaced by migration def456)
- `migrate_time_off.py`: Created time_off table (in initial migration)
- `update_employee_list.py`: Data sync script (now handled by sync_engine.py)
- `update_event_types.py`: Event type detection (replaced by migration ghi789)

## Migration Equivalents

| Old Script | New Migration | Notes |
|------------|---------------|-------|
| migrate_employee_ids.py | abc123_update_employee_ids.py | Converted to Alembic |
| update_event_types.py | def789_add_event_type_column.py | Includes data population |

EOF
```

---

### **Phase 4: Workflow and Best Practices**

#### **Step 4.1: Model Change Workflow**

**System Prompt:**
```
Teach developers the proper workflow for making model changes.
This prevents common migration mistakes.
```

**Standard Workflow:**

```bash
# 1. Make changes to models in app.py
# Example: Add new column to Employee model

class Employee(db.Model):
    # ... existing columns ...
    department = db.Column(db.String(50))  # NEW COLUMN

# 2. Generate migration
cd scheduler_app
flask db migrate -m "Add department column to Employee"

# 3. Review generated migration
cat migrations/versions/xyz123_add_department_column_to_employee.py

# 4. Edit if needed (add data transformations, etc.)
nano migrations/versions/xyz123_add_department_column_to_employee.py

# 5. Test on development database
flask db upgrade

# 6. Verify app still works
python app.py

# 7. Test downgrade (rollback)
flask db downgrade

# 8. Upgrade again
flask db upgrade

# 9. Commit migration to Git
git add migrations/versions/xyz123_add_department_column_to_employee.py
git add app.py  # The model changes
git commit -m "Add department tracking to Employee model

- Added department column (String 50)
- Migration: xyz123
- Defaults to NULL for existing employees"
```

**Why this order:**
1. Change models first = source of truth
2. Generate migration = captures changes automatically
3. Review = catch auto-generation mistakes
4. Test = prevent data loss
5. Commit = share with team

---

#### **Step 4.2: Team Workflow**

**System Prompt:**
```
When another developer pulls migration changes, they must apply them.
Create clear documentation for this workflow.
```

**Create scheduler_app/migrations/WORKFLOW.md:**

```markdown
# Database Migration Workflow

## When You Pull Changes

If someone added a migration, you'll see new files in `migrations/versions/`.

**Run this every time you pull:**

```bash
cd scheduler_app

# Check current migration state
flask db current

# Apply any pending migrations
flask db upgrade

# Restart app
python app.py
```

**How to know if you need to run migrations:**

```bash
# Show pending migrations
flask db show

# Or just run upgrade (it's safe to run multiple times)
flask db upgrade
```

## When You Make Model Changes

**Never manually edit the database!** Always use migrations.

### 1. Edit the model

```python
# app.py
class Employee(db.Model):
    new_field = db.Column(db.String(100))  # Your change
```

### 2. Generate migration

```bash
flask db migrate -m "Descriptive message about the change"
```

### 3. Review the generated file

```bash
# Open newest migration
ls -lt migrations/versions/*.py | head -1
```

Check:
- Does it capture all your changes?
- Does downgrade() reverse it properly?
- Any data transformations needed?

### 4. Test it

```bash
# Backup first!
cp instance/scheduler.db instance/scheduler.db.backup

# Apply migration
flask db upgrade

# Test app
python app.py

# Test rollback
flask db downgrade
flask db upgrade
```

### 5. Commit it

```bash
git add migrations/versions/abc123_your_migration.py
git add app.py  # Your model changes
git commit -m "Add new_field to Employee model"
```

## Common Commands

| Command | Purpose |
|---------|---------|
| `flask db current` | Show current migration version |
| `flask db history` | Show all migrations |
| `flask db upgrade` | Apply pending migrations |
| `flask db downgrade` | Rollback last migration |
| `flask db show` | Show pending migrations |
| `flask db migrate -m "msg"` | Generate new migration |

## Troubleshooting

### "Can't locate revision identified by 'xyz'"

You're missing a migration file. Pull from Git:

```bash
git pull
flask db upgrade
```

### "Target database is not up to date"

You need to run migrations:

```bash
flask db upgrade
```

### "Multiple head revisions detected"

Someone committed a migration while you were working:

```bash
# Merge the heads
flask db merge -m "Merge database heads" abc123 def456
flask db upgrade
```

### Migration failed with error

```bash
# Restore from backup
cp instance/scheduler.db.backup instance/scheduler.db

# Fix the migration script
nano migrations/versions/failed_migration.py

# Try again
flask db upgrade
```

## Production Deployment

**ALWAYS test migrations on staging first!**

```bash
# On staging server:
1. Backup database
2. flask db upgrade
3. Test application thoroughly
4. If issues: flask db downgrade

# On production:
1. Backup database
2. Set maintenance mode
3. flask db upgrade
4. Verify database integrity
5. Test application
6. Remove maintenance mode
```

## Data Migrations

For complex data transformations, edit the generated migration:

```python
def upgrade():
    # Add column
    op.add_column('employees', sa.Column('full_name', sa.String(200)))

    # Transform data
    connection = op.get_bind()
    connection.execute("""
        UPDATE employees
        SET full_name = first_name || ' ' || last_name
    """)

    # Make required
    op.alter_column('employees', 'full_name', nullable=False)
```
```

---

#### **Step 4.3: Create Migration Helper Scripts**

**System Prompt:**
```
Create convenient wrapper scripts for common migration tasks.
```

**Create scheduler_app/db_migrate.sh:**

```bash
#!/bin/bash
# Database migration helper script

set -e  # Exit on error

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"

# Activate virtual environment if it exists
if [ -d "../venv" ]; then
    source ../venv/bin/activate
fi

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Functions
backup_db() {
    if [ -f "instance/scheduler.db" ]; then
        BACKUP_FILE="instance/scheduler_backup_$(date +%Y%m%d_%H%M%S).db"
        cp instance/scheduler.db "$BACKUP_FILE"
        echo -e "${GREEN}✓ Database backed up to: $BACKUP_FILE${NC}"
    fi
}

show_status() {
    echo -e "${YELLOW}Current migration status:${NC}"
    flask db current
    echo ""
    echo -e "${YELLOW}Migration history:${NC}"
    flask db history
}

upgrade_db() {
    echo -e "${YELLOW}Running migrations...${NC}"
    flask db upgrade
    echo -e "${GREEN}✓ Migrations applied successfully${NC}"
}

create_migration() {
    if [ -z "$1" ]; then
        echo -e "${RED}Error: Please provide a migration message${NC}"
        echo "Usage: ./db_migrate.sh create \"Your message here\""
        exit 1
    fi

    echo -e "${YELLOW}Generating migration: $1${NC}"
    flask db migrate -m "$1"
    echo -e "${GREEN}✓ Migration created${NC}"
    echo ""
    echo "Please review the generated migration file before applying it!"
    ls -lt migrations/versions/*.py | head -1
}

rollback() {
    echo -e "${YELLOW}Rolling back last migration...${NC}"
    flask db downgrade
    echo -e "${GREEN}✓ Rollback complete${NC}"
}

# Main menu
case "$1" in
    status)
        show_status
        ;;
    upgrade)
        backup_db
        upgrade_db
        ;;
    create)
        create_migration "$2"
        ;;
    rollback)
        backup_db
        rollback
        ;;
    backup)
        backup_db
        ;;
    *)
        echo "Database Migration Helper"
        echo ""
        echo "Usage: ./db_migrate.sh [command]"
        echo ""
        echo "Commands:"
        echo "  status              - Show current migration status"
        echo "  upgrade             - Apply pending migrations (auto-backup)"
        echo "  create \"message\"    - Generate new migration"
        echo "  rollback            - Undo last migration (auto-backup)"
        echo "  backup              - Backup database manually"
        echo ""
        echo "Examples:"
        echo "  ./db_migrate.sh status"
        echo "  ./db_migrate.sh create \"Add email field to Employee\""
        echo "  ./db_migrate.sh upgrade"
        ;;
esac
```

**Make executable:**
```bash
chmod +x scheduler_app/db_migrate.sh
```

**Usage examples:**
```bash
# Check migration status
./db_migrate.sh status

# Create new migration
./db_migrate.sh create "Add department to employees"

# Apply migrations with automatic backup
./db_migrate.sh upgrade

# Rollback last migration
./db_migrate.sh rollback
```

---

### **Phase 5: Testing and Validation**

#### **Step 5.1: Test Complete Migration Lifecycle**

**System Prompt:**
```
Perform end-to-end testing of the migration system.
This ensures everything works before team adoption.
```

**Test Script:**

```bash
#!/bin/bash
# Complete migration system test

set -e
cd scheduler_app

echo "=== Migration System Test ==="
echo ""

# Test 1: Check current state
echo "✓ Test 1: Checking current migration state..."
flask db current

# Test 2: Show history
echo "✓ Test 2: Showing migration history..."
flask db history | head -5

# Test 3: Create a test migration
echo "✓ Test 3: Creating test migration..."
# Add a test column to Employee model temporarily
cat > test_migration_model.py << 'EOF'
# Temporary test: Add column
from app import db, Employee
Employee.test_column = db.Column(db.String(50))
EOF

# Generate migration
flask db migrate -m "TEST migration - will be rolled back"

# Test 4: Apply migration
echo "✓ Test 4: Applying test migration..."
flask db upgrade

# Test 5: Verify database has the change
echo "✓ Test 5: Verifying database schema..."
sqlite3 instance/scheduler.db ".schema employees" | grep -q "test_column" && echo "Column added successfully"

# Test 6: Rollback migration
echo "✓ Test 6: Rolling back migration..."
flask db downgrade

# Test 7: Verify rollback worked
echo "✓ Test 7: Verifying rollback..."
! sqlite3 instance/scheduler.db ".schema employees" | grep -q "test_column" && echo "Column removed successfully"

# Clean up test migration
echo "✓ Cleaning up test migration..."
rm -f migrations/versions/*test_migration*.py
rm -f test_migration_model.py

# Upgrade back to latest
flask db upgrade

echo ""
echo "=== All Tests Passed! ==="
echo "✓ Migration system is working correctly"
```

---

#### **Step 5.2: Document Migration Benefits**

**Add to README.md:**

```markdown
## Database Migrations

This project uses Flask-Migrate (Alembic) for database schema management.

### Benefits

✅ **Version Control**: Track database schema changes in Git
✅ **Repeatability**: Apply same changes across dev/staging/production
✅ **Safety**: Automatic backups and rollback capability
✅ **Team Coordination**: No more "which script do I run?"
✅ **Automatic**: Generate migrations from model changes

### Quick Start

```bash
# Apply latest migrations
cd scheduler_app
flask db upgrade

# Check status
flask db current
```

See `scheduler_app/migrations/WORKFLOW.md` for complete documentation.

### Migration Commands

| Command | Purpose |
|---------|---------|
| `flask db upgrade` | Apply pending migrations |
| `flask db current` | Show current version |
| `flask db history` | List all migrations |
| `flask db downgrade` | Rollback last migration |
| `flask db migrate -m "msg"` | Create new migration |

### Important Notes

⚠️ **Always backup before migrations in production**
⚠️ **Review autogenerated migrations before applying**
⚠️ **Test migrations on dev/staging first**
```

---

## **Summary & Checklist**

### **What We Accomplished**

✅ Installed Flask-Migrate
✅ Initialized migration repository
✅ Created initial migration from existing schema
✅ Converted manual scripts to migrations
✅ Documented team workflow
✅ Created helper scripts
✅ Tested migration lifecycle

### **Before Deployment Checklist**

- [ ] Flask-Migrate added to requirements.txt
- [ ] Migration repository initialized
- [ ] Initial migration created and stamped
- [ ] All manual scripts converted or archived
- [ ] Team workflow documented
- [ ] Helper scripts created and tested
- [ ] All tests pass
- [ ] Team trained on new workflow

### **Production Deployment Steps**

```bash
# 1. Backup production database
pg_dump production_db > backup_$(date +%Y%m%d).sql

# 2. Test migrations on staging first
# (staging should be copy of production)

# 3. Enable maintenance mode

# 4. Apply migrations
flask db upgrade

# 5. Verify database integrity
# Run health checks

# 6. Test application

# 7. Disable maintenance mode
```

---

## **Estimated Time**

- **Setup and initialization**: 1 hour
- **Convert manual migrations**: 2-3 hours
- **Testing**: 1 hour
- **Documentation**: 1 hour
- **Team training**: 1 hour

**Total**: 6-7 hours

---

## **Success Criteria**

✅ Can create migrations with `flask db migrate`
✅ Can apply migrations with `flask db upgrade`
✅ Can rollback with `flask db downgrade`
✅ Migrations tracked in version control
✅ Team understands workflow
✅ Manual scripts archived
✅ Production deployment process documented
